---
title: "R wizardry course Week 3, 2017"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
proc.time()
```




# Week 3 content

1.1 How to create projects in R
1.2. Arithmetic operators
1.3 Calculations based on another column
1.4 Brief intro to graphs using R base plotting functions
1.5 Create and export a summary table
1.6 Selecting data based on another column
1.7 Finding data based on its value
1.8 Random numbers and selecting random data
1.9 Strings



## Before starting:
* Googling and solving R errors

* Reminder about office hours dinamyc: send your question in advance and show us you have searched the aswer by yourself. We're not being mean, this is simply the way how learning programming works...

* Mid term feedback

* Some examples of final projects from previous years

* Upload homework 1 to D2L.

* Disccuss homeworks solutions.

** During this lecture we will build data to work on compounds data set for plotting and some more data management

## Arithmetic operators

```{r}
rm(list=ls(all=TRUE))


?"%%"
help("%%")

```


To find "types" of numbers, %/% and %% are handy

```{r}

# %% returns the remainder


# %/% returns the quotient


#Even numbers



#numbers divisible by 5 or 6



# Numbers that are not divisible by 4


```



Can also use brackets for more complicated selections

```{r}

```


### Problem 1
Use logical operators to simultaneously find the odd numbers between -50 and 0 (inclusive) and the even numbers between 0 and 50 (inclusive)

```{r}


```



## Missing data and NA's
First, let's read a preiously saved image of the dataset from the previous lecture that we change into long format.

```{r}
rm(list=ls(all=TRUE))
```


Load the long-format "Compounds" dataset created during week 2 (the compressed file with the extension ".rds").

```{r}


#Import data by setting the working directory and then read the file of interest


#Another option, specfing the full path to the file of interst:


```


Can use subset() to split the data based on some logical argument contained within the dataset. For example, let's only look at data from the first half of the experiment (before day 200)

```{r}



```


Adding a column of NEW DATA to an existing dataset

```{r}



# Alternatively could do that more robustly

```


NA represents an empty slot and are also produced when invalid math is attempted. In addition to TRUE and FALSE, NA is another type of logical variable

```{r}

```


Unfortunately, we often have to deal with missing data so lets throw some in
```{r}


```

Having NA messes up a lot of functions
```{r}


```


Often there are built in ways to ignore them most common functions have a parameter such as na.rm, na.omit, na.exclude, etc...
```{r}

```

But we can use logic to ignore them ourselves using is.na()
```{r}


```


### Problem 2:
Select the data from column 5 which is not NA and calculate its mean.

```{r}


#First we ask about NAs in column 5, then we subset data to use column 5. That's why column 5 is called twice in the code below


```




## 1.3 Calculations based on another column

```{r}

```


"tapply()" applys a function to one column based on the groups found in another column
```{r}


#Methane based on salinity or group factors


```



Aggregate is the general form, allowing you to group by more than one column.

```{r}



#A disadvantage of "aggregate()" is that you have to rename the columns


```


ALTERNATIVELY, this form keeps the names

```{r}


```


A third way to use aggregate. Let's calculate the mean and standard deviation in the methane reads by day.

```{r}



```



### Problem 3

At this points there are two datasets that only differ in one column: one contains the mean and the other the standars deviation. Also, rename the columns with more addecuate names.

```{r}



#Alternatively,


```


Let's say you wanted to quickly calculate your sample size for each categorical factor of compound and group. How would we do that in such a way that R is not counting the NAs?

There are three ways:

```{r}


```


## 1.4 Brief intro to graphs using R base plotting functions
Although during the course we won't use the basic R plotting that much as we'll focus on the ggplot2 package, it's good to understand the very basics.


```{r}

```


Here is a variety of ways to plot box-and-whisker plots in R

```{r}



```


## 1.5 Create and export a summary table

```{r}


```

... and warnings to it
```{r}



```


## 1.6 Selecting data based on another column

We have been selecting data based on itself. We can also select data based on other data.

We can find the odd letters
```{r}

```

We can select the data collected on day 1
```{r}

```


We can select the data collected on day 1 and day 10
```{r}

```


We can select based on 2 or more data types
```{r}

```


We can store this subsetted data into a new variable
```{r}




```


## 1.7 Finding data based on its value


```{r}



#Get the row number containing the highest methane read


#Get the entire info of row containing the highest methane read


```

## 1.8 Random numbers and selecting random data

```{r}

```

## 1.9 Strings

```{r}
rm(list=ls(all=TRUE))



```

### 1.9.1 Logical operators on strings
```{r}



# R is smart (sometimes), for logical operators it ranks character sequences alpha-numerically

```


### 1.9.2 Combining strings
```{r}



#Use the paste function to combine multiple vectors of character data into a single string



#Can change the seperation using the sep parameter




# can combine multiple objects from a single vector into a single string


#Can combine any one-celled variable



#If you have multi-celled variables, you will create multiple strings


```


### 1.9.3 Seperating strings
```{r}



#substring (aka substr) and strsplit can seperate strings

#substring grabs the characters between two points in the string


#nchar tells you how long the string is


#strsplit seperates the string into fragments
#It makes breaks when it finds the string you want within the larger string


#The string you are breaking on is not included in the output


#strsplit puts its output inside of a list (since the arrays in the list can be of different sizes)

#We get pull the relevant vector/array out of a list using [[NUMBER]]



#We can use sapply if our list has multiple slots and each array is the same size


#The ".*X" syntax is a regular expression that is recognizable to perl and other languages
#It is matching the X argument after any given string, in this case it is matching on the 
#colon (:) and splitting the string and ignoring everything prior to the colon



# Try a value of 1, and a value of 2 here
# Why does the sapply function work???
# because the command "[" is a command to R to extract information specific to lists
# and the function 'strsplit' creates an object formatted as a list



```

### 1.9.4 Managing strings

```{r}





## ^^ Try different values instead of 4, such as 3, 5, 1, etc.


# ^^ Try different values for 1 above


```



### 1.9.5 Matching strings

```{r}

```


### 1.9.6 Partial matches and regular expressions

```{r}

```



Let's create a fake sequence of genomic data, 100,000 bp long each of the 4 bp A, C, G, and T have equal probability of being represented we want to sample from the letters a, c, g, and t, with replacement

```{r}

```

this gives us the individual vector positions of the genome for each bp
```{r}

```


let's collapse this down into a single character vector
```{r}

```

let's say that we are interested in finding out where/if a specific sequence occurs the sequence of interest is GATTACA

```{r}

```


We can use regular expressions to find out where among the single character vector that R first returns a positive hit for GATTACA

```{r}

```

Let's verify that this is indeed the bp in the genome corresponding to that return
```{r}

```


Let's then split the genomic sequence up around GATTACA (i.e., split the genomic sequence up and remove GATTACA). For each positive hit on GATTACA, it will split split the vector
```{r}



```


does each remaining subsection of the genome contain GATTACA?
```{r}
```


What if you were then interested in the pieces of the genome that contained an additional bp sequence of interest, such as AAACGGG?

```{r}

```


Alternatively you could do this:
```{r}


#rinse and repeat to find all genomic locations that contain GATTACA bp sequence
```

