---
title: "R wizardry course week 5 (final), 2017"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
proc.time()
```

# Week 5 content

5.1 for loops
5.2 cycle through values
5.3 inclass problem
5.4 if statements
5.5 inclass problems
5.6 debugging loops
5.7 while loops
5.8 Next and break
5.9 Nested looping

```{r}

rm(list=ls(all=TRUE))

setwd("/Admin/desktop/R/Datasets/")
data <- read.csv("/home/oscar/Dropbox/R wizardry/2017/Datasets/compounds_triplicates_long.csv",header=T,stringsAsFactors = FALSE)

```

## 5.1 for loops

R doesn't care if you write something 1000 times or have it copy it 1000 times
But the second is a lot easier for you

```{r}
library(dplyr)
i <- 2
i <- i + 2 %>% print()
i <- i + 2
i <- i + 2
i <- i + 2
i <- i + 2
i <- i + 2
i

i <- 2
for(counter in 1:6)
{
	i <- i + 2
	print(i)
}
i

```


for loops have two stages
1. Set a variable to equal the next value in a sequence
2. Run a set of code with that variable at that value
3. Repeat

```{r}

for(variable in seq(1,10,0.5))
{
	print(variable)
}

```

R either takes the rest of the line, the next line, or everything within { } as the looped code

```{r}

i <- 1
for(counter in 1:6) i <- i + 2
i

i <- 1
for(counter in 1:6)
  i <- i + 2

i <- 1
for(counter in 1:6)
{
  i <- i + 2
}
i

i <- 1
for(counter in 1:6){
  i <- i + 2
}
i

```

We can use the variable simply as a tracker to repeat code a given number of times
For example, we can replicate the rep() function

```{r}

x <- 1:5
n <- 10

seq <- x
for(i in 1:(n-1))
{
	seq <- c(seq, x)
	print(seq)
}
length(seq)/5

```


## 5.2 cycle through values

The most useful thing to do with a for loop is to cycle through values

```{r}
colnames(data)
plot(mean_methane ~ day, col = 0, data) #empty plot
#We can use the variable to select different data each time
for(i in 1:dim(data)[1])
{
	points(mean_methane ~ day, data[i,], 
	       col=heat.colors(dim(data)[1])[i],pch=20)
} 
#methane per day of each indivual row
data
```

## 5.3 inclass problems
Replicate the tapply() function (you don't need it to have the same formatting)

```{r}

tapply(data$mean_methane, data$compound, mean, na.rm=TRUE)

compound <- data.frame("compound" = unique(data$compound),"mean_methane" = 0)
compound

head(data, 15)
str(data)
for(i in 1:dim(compound)[1])
{
	temp <- compound[i,1]
	compound[i,2] <- mean(data[data$compound == temp,"mean_methane"],na.rm=TRUE)
}
compound

#Alternatively
#You can use the data directly instead of the length

compound <- data.frame("compound" = unique(data$compound),"mean_methane" = 0)
compound

for(i in unique(data$compound))
{
  pos<- which(unique(data$compound) == i )
  compound[pos, 2] <- mean(data[data$compound == i, "mean_methane"],na.rm=TRUE)
}
compound

tapply(data$mean_methane, data$compound, mean, na.rm=TRUE)
```


## 5.4 if statements

The big advantage of programming is you can have R make decisions.
Allows code to be flexible, dont have to rewrite everything if you change the data
R makes binary decisions: "if data meets a condition, do this thing or else do this other thing"
if(conditional argument that leads to one F or T outcome)

```{r}

i <- 1
if(TRUE) i <- "monkey"
i

i <- 1
if(FALSE) i <- "elephant"
i

```

R either takes the rest of the line, the next line, or everything within { } as the conditional action

```{r}

if(TRUE) i <- 4
i

if(TRUE)
i <- "monkey"

if(FALSE)
i <- 5
i <- 6

i <- 1
if(FALSE)
{
	i <- 5
	i <- 6
}
i

```

if() is useful if we have R make the decision for us

```{r}

i <- 6
if(i < 5)
i <- 0
i

```

We can use the else statement for efficiency if we want an alternative thing to be done only when the first thing is not done else goes after the if() task and runs using the same rules as an if() task

```{r}

i <- 4
if(i < 5)
	i <- 0 else
	i <- 1
i

i <- 4
if(i < 5){
  i <- 0
}else{
	 i <- 1
}
i

```

For simple tasks, ifelse() puts it all in one function
Need to use <- instead of =

```{r}

i <- 4
ifelse (i < 5, a <- 1, a <- 2)

a

ifelse(i<0, a<-1, a<-2)
a


#Can also use ifelse() for staggered data selection
ifelse(letters < "h" , "hippo", 1)

```


## 5.5 inclass problems
Use t-test to look for methane production diffrences between the salinity levels of every 10th day (starting at day 2), excluding the "BRACKISH" salinity.

```{r}

#subset dataset for every 10th day and exclude brackish
subdata <- data[data$day%%10 == 2 & data$salinity!="brackish",]
result <- data.frame(day = unique(subdata$day), diff = 0, p = 0)
for(i in unique(subdata$day))
{
	t <- t.test(mean_methane ~ salinity, subdata[subdata$day == i,])
  result[result$day == i,2] <- diff(t$estimate)#this is just for storing results in specific position inside the data frame
	result[result$day == i,3] <- t$p.value
}
result

```

Now use an if statement so you don't have to subset your data by day

```{r}

result <- NULL
subdata <- subset(data, data$salinity!="brackish")
for(i in unique(subdata$day))
	if(i%%10 == 2)
	{
		t <- t.test(mean_methane ~ salinity, subdata[subdata$day == i,])
		temp <- data.frame(day = i, diff = as.numeric(diff(t$estimate)), p = t$p.value)
		result <- rbind(result, temp)
	}
result

result <- NULL
for(i in unique(data$day))
	if(i%%10 == 2)
	{
		t <- t.test(mean_methane ~ salinity, data[data$day == i & data$salinity != "brackish",])
		temp <- data.frame(day = i, diff = as.numeric(diff(t$estimate)), p = t$p.value)
		result <- rbind(result, temp)
	}
result

```

## 5.6 debugging loops

```{r}
#Sy.sleep can help you debug your for loops by slowing it down (if combined with a print or plot function)

for(variable in c("First I was \nafraid", "I was petrified", "Kept thinking \nI could never", "live without \nyou by my side"))

for(variable in c("As", "you", "wish")) 
{
  plot(0, col=0)
  text(1,0,variable,cex=4)
  Sys.sleep(1.2) #stop for 1 second before going to the second interation
}

#print can help you figure out where you loop is breaking down
x <- 0
for(i in 15:30)
{
  #print(i)
  if(data[i,"mean_methane"] > 20) x <- x + 1
}
x
i <- 24
#You can also set the variable you are looping with to different value to see what happens

```

## 5.7 while loops

```{r}

x <- 0
while(x < 10)
{
  x <- x + 1
  print(x)
}

x <- 10
while(x < 10)
{
  x <- x + 1
  print(x)
}

#Only checks if the statement is true on each loop
x <- 1
while(x < 10)
{
  x <- x + 1
  x <- x + 1
  x <- x + 1
  x <- x + 1
  print(x)
}

#you can press escape to stop the code
x <- 1
while(x < 2)
{
  print(x)
  Sys.sleep(1)
}

```

## 5.8 Next and break

```{r}

for(i in 1:10)
{
  if (i > 5) break
  print(i)
}

#or
for(i in 1:10)
{
  if (i > 5) 
    {
    break
    }
    print(i)
}

#Skip a value (iteration) using next
for(i in 1:10)
{
  if(i > 3 & i < 7) next
  print(i)
}

#Skipping nonexistant data
subdata <- data[data$day %% 10 == 1 | data$day %% 10 == 2, ]
for(i in 1:499) #for(i in 1:nrow(subdata)) #More generic
{
  temp <- subdata[subdata$day == i, ]
  if(dim(temp)[1] == 0)
    next
  boxplot(mean_methane~compound, temp,
          main = paste('Day', i, sep = "="),
          ylim = c(-5, 120))
}

```

## 5.9 Nested looping

```{r}

gene <- "gattaca"
ngenes <- 10000
nbasepairs <- 15
genome <- matrix(NA, nrow = ngenes, ncol = nbasepairs)
genes <- NULL

set.seed(123)
for(i in 1:ngenes)
{
  for(j in 1:nbasepairs)
  {
    genome[i,j] <- sample(c('a', 'c', 'g', 't'), 1,
                          replace = TRUE, prob = c(1/4,1/4,1/4,1/4))
  }
  genes[i] <- paste(genome[i,1:nbasepairs], collapse = '') 
}

genes[1:2]
genome[1:2,]

gene.location <- grep(gene, genes)
genes[gene.location]

#mixing and matching flow control

set.seed(789)
plot(0, xlim =  c(0, 1000), ylim = c (0, 1000), col = 0)
total <- 0

for(i in 1:8)
{
  allele <- 500
  x <- 0
  while(allele < 1000 & allele > 0)
  {
    if(x >= 1000)
    {
      total <- total + 1
      break
    }
    points(allele ~ x, col = i)
    allele <- allele + rnorm(1, mean = 0, sd = 10)
    x <- x + 1
  }
}
total

```