---
title: "R wizardry course week 6, 2017"

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
rm(list=ls(all=T))
```


```{r}
#setwd("/home/oscar/Dropbox/R wizardry TA")
data <- read.csv("/home/oscar/Dropbox/R wizardry/2017/Datasets/SimDataTrend.csv")
```


# Week 6 content. Customized functions.

6.1 General structure of a function
6.2 Creating a custom function: Standard Error
6.3 Passing custom functions to other functions: Aggregate
6.4 Coding a 'robust' custom function: What about NAs?
6.5 Functions for complex analyses: Mixing FOR loops and FUNCTIONS
6.6 Looping across complex functions/analyses
6.7 Plotting the above results


## 6.1.1 General structure of a function

```{r}
help("function")
```

FUN <- function(ARGUMENT1 = object1, ARGUMENT2 = object2, ... )
{
  ARGUMENT1 () = FIRST THING TO DO
  ARGUMENT 2 () = SECOND THING TO DO 
  ... = OPTIONAL ARGUMENTS, means "expect more instructions"
  
  return(THE ITEM/SOLUTION/OBJECT/VALUE OF INTEREST)
}


To call and execute the function, type the name of the function and pass the parameters/object of interest to the correspondent arguments. The objects don't need to be preceeded by the name of the argument. However, if you decide not to use the ARGUEMNT name, make sure you you add the objects in the same order you decided to add them when you created the function. For example, FUN(object1, object2) will return a different result than FUN(object2, object1), but FUN(ARGUMENT1 = object1, ARGUMENT2 = object2) and FUN(ARGUMENT2 = object2, ARGUMENT1 = object1) will return the same result.


## 6.2 Creating a custom function: Standard Error

By definition, SE is the sd of the sample-mean's divided by the sqrt of the sample size.
```{r}
?sqrt
?sd
?length
```


The following two functions are equivalent and will return the same answer:

Option 1

The code below creates a standard error (SE) function that can be used with our dataset.
```{r}

```

Option 2

The code below returns both the SE and the MEAN of mydata
```{r}


```


## 6.3 Passing custom functions to other functions: Aggregate

```{r}

```


## 6.4 Coding a 'robust' custom function: What about NAs?


Let's introduce missing data into SimData


```{r}
?sample



```


Now, run SE on the new SimData with the introduced NAs
```{r}

```


We need to add some argument to handle missing data (NA)
```{r}


```


## 6.5 Functions for complex analyses: Mixing FOR loops and FUNCTIONS


Power Analyses
Help us to determine a sample size required to detect an effect of a given size with a given degree of confidence. 

Let's create Markov Chain Monte Carlo (MCMC) simulation (a Bayesian-based method).

Knowing the difference in mean biomass between tretments and controls, we can compute the probability of observing a value as large as we did, referred to as a p-value

First, let's take a look at t-tests in R
```{r}


```


```{r}
?rbind
?order
?diff 
```




## 6.6 Looping across complex functions/analyses

```{r}

```



## 6.7 Plotting the above results

```{r}

```



